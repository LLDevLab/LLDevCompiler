// Returns an address of peripherial's register
// Arguments:
// 	- An offset
lldevcpu_get_periph_addr:
push r12
// Create the stack frame
// Move current SP value to r12 register
mov r12, r14
push r2
// Get parameter from the stack
// Set map of RAM addresses
ldi r0, #2
lsh r0, #28
// Or'ing stack frame with the map
or r0, r12
// First parameter will have an offset r12 + 3
ldi r2, #3
add r0, r2
// Load parameter's value to r2 register
ld r2, r0
// Set map of Peripherals
ldi r0, #0x300000
lsh r0, #8
// Add offset to peripherals address
or r0, r2
// Exit from function
pop r2
pop r12
ret

// Stores value to RAM within specified offset
// Arguments:
// 	- An offset 
// 	- A value to store
lldevcpu_set_ram_val:
push r12
mov r12, r14
push r0
push r1
push r2
push r3
push r4
// Get "offset" parameter from the stack
// Set map of RAM addresses
ldi r0, #2
lsh r0, #28
// Save map to r1 register
mov r1, r0
// Or'ing stack frame with the map
or r0, r12
// First parameter will have an offset r12 + 4
ldi r2, #4
add r2, r0
// Load "offset" to r3 register
ld r3, r2
// Adding a RAM map to parameters value
add r3, r1
// Get "value" parameter from the stack
// Second parameter will have an offset r12 + 3
ldi r2, #3
add r2, r0
// Load "value" parameter from the stack to r3 register
ld r4, r2
// Store value to RAM address
st r3, r4
// Exit from function
pop r4
pop r3
pop r2
pop r1
pop r0
pop r12
ret

// Returns RAM value, stored within specified offset
// Arguments:
// 	- An offset 
lldevcpu_get_ram_val:
push r12
mov r12, r14
push r1
push r2
push r3
// Get parameter from the stack
// Set map of RAM addresses (r0 will be used to return value, so I don't need to save it)
ldi r0, #2
lsh r0, #28
// Save RAM map to r1 register
mov r1, r0
// Or'ing stack frame with the map
or r0, r12
// First parameter will have an offset r12 + 3
ldi r2, #3
add r2, r0
// Load parameter's value to r3 register
ld r3, r2
// Adding a RAM map to parameters value
add r3, r1
// Load value from RAM (with specified offset) to r0 register
ld r0, r3
// Exit from function
pop r3
pop r2
pop r1
pop r12
ret

// Waiting for approximately 1 ms
lldevcpu_wait_one_ms:
push r0
push r1
push r2
ldi r0, #0xa2c2
ldi r1, #1
ldi r2, wait_one_ms_loop
wait_one_ms_loop:
sub r0, r1
brne r2
pop r2
pop r1
pop r0
ret
