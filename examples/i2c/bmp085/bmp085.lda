// Get calibration of bmp085 device
bmp085_get_calibrations:
push r0
push r1
push r2
push r3
push r4
push r5
// r0 - calibration register msb address
// r1 - loop iteration counter
// r2 - loop max iteration
// r3 - holds loop increment value
// r4 - register, that holds temporary values
// r5 - register to hold received calibration value
ldi r0, #0xaa
clr r1
// 22 because 11 msb values and 11 lsb values
ldi r2, #11
ldi r3, #1
// Send calibration registers msb
bmp085_get_calibrations_loop:
// send start condition
ldi r4, i2c_send_start_signal
call r4
// send bmp085 write address
ldi r4, bmp085_send_write_addr
call r4
// send bmp085 register address to read
push r0
ldi r4, bmp085_send_data
call r4
pop r0
// read data from sensor
// send start condition
ldi r4, i2c_send_start_signal
call r4
// send bmp085 read address
ldi r4, bmp085_send_read_addr
call r4
// save current value of r0
push r0
// Setting ack state to "ack"
ldi r0, #1
push r0
ldi r0, i2c_set_ack_state
call r0
pop r0
// receive msb of calibration
ldi r4, i2c_receive_data
call r4
mov r5, r0
lsh r5, #8
// receive lsb of calibration
// Setting ack state to "nack"
clr r0
push r0
ldi r0, i2c_set_ack_state
call r0
pop r0
// r4 still holds i2c_receive_data value
call r4
or r5, r0
// restore value of r0
pop r0
ldi r4, i2c_send_stop_signal
call r4
// save value of r0
push r0
// Check readed calibration
push r5
ldi r5, bmp085_calibration_correct
call r5
pop r5
clr r4
cmp r0, r4
ldi r4, bmp085_get_calibrations_loop
// restore value of r0
pop r0
// if calibration is not correct try to read it once more
breq r4
// pass second parameter to function (array index)
push r1
// pass first parameter to function
push r5
ldi r5, heap_save
call r5
pop r5
pop r1
// increment calibration msb by 2
add r0, r3
add r0, r3
// increment loop counter by 1
add r1, r3
ldi r4, bmp085_get_calibrations_loop
cmp r1, r2
brne r4
// breakpoint
//bmp085_get_calibrations_bkpt1:
//ldi r4, bmp085_get_calibrations_bkpt1
//br r4
// Restore the stack and return from function
pop r5
pop r4
pop r3
pop r2
pop r1
pop r0
ret

// Checks does calibration correct. Calibration cannot be 0x0000 or 0xffff
// Arguments:
// - Calibration value to check
// Returns 0 if calibration is not correct and 1 if calibration is correct.
bmp085_calibration_correct:
push r12
mov r12, r14
// Not save r0 value, because it will be overwriten by return value
push r1
// Get first parameter from the stack
// Set map of RAM addresses
ldi r0, #2
lsh r0, #28
// Or'ing stack frame with the map
or r0, r12
// Parameter will have an offset r12 + 3
ldi r1, #3
add r0, r1
// Load parameter's value to r1 register
ld r1, r0
// Checking for 0x0000
clr r0
cmp r1, r0
ldi r0, bmp085_calibration_is_not_correct
breq r0
// Checking for 0xffff
ldi r0, #0xffff
cmp r1, r0
ldi r0, bmp085_calibration_is_correct
brne r0
bmp085_calibration_is_not_correct:
clr r0
ldi r1, bmp085_calibration_correct_ret
br r1
bmp085_calibration_is_correct:
ldi r0, #1
bmp085_calibration_correct_ret:
pop r1
pop r12
ret

// Sending a write address to bmp085
bmp085_send_write_addr:
push r0
ldi r0, #0xee
// pass parameter to the function
push r0
ldi r0, bmp085_send_data
call r0
pop r0
// Restore the stack and return from the function
pop r0
ret

// Sending a read address to bmp085
bmp085_send_read_addr:
push r0
ldi r0, #0xef
// pass parameter to the function
push r0
ldi r0, bmp085_send_data
call r0
pop r0
// Restore the stack and return from the function
pop r0
ret

// Sending data to bmp085 device
// Arguments:
// 	- A data to send
bmp085_send_data:
push r12
mov r12, r14
push r0
push r1
// Get first parameter from the stack
// Set map of RAM addresses
ldi r0, #2
lsh r0, #28
// Or'ing stack frame with the map
or r0, r12
// Parameter will have an offset r12 + 3
ldi r1, #3
add r0, r1
// Load parameter's value to r1 register
ld r1, r0
// Set parameter's data to "i2c data input/output register"
push r1
ldi r1, i2c_set_data
call r1
pop r1
// Start data transmission
ldi r1, i2c_send_data
call r1
// Restore the stack and return from function
pop r1
pop r0
pop r12
ret
